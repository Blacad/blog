```
increment = lambda x: x + 1
def make_repeater(f, n):
    """Returns the function that computes the nth application of f.

    >>> add_three = make_repeater(increment, 3)
    >>> add_three(5)
    8
    >>> make_repeater(triple, 5)(1) # 3 * (3 * (3 * (3 * (3 * 1))))
    243
    >>> make_repeater(square, 2)(5) # square(square(5))
    625
    >>> make_repeater(square, 3)(5) # square(square(square(5)))
    390625
    """
    # 其中注释的部分会产生无限递归的问题。
    # 这个的主要原因是最终lamda表达式中的f 绑定的也是最终的f，
    # 因此它并不像洋葱而像没有base的递归函数。
    # 而下方修改的方法将每层的状态f都保存了因此像洋葱一样可以展开。
    # 可以用tutor可视化看两种方法的区别。
    # 但是我的建议是用def语句来实现本功能如f1函数更加清晰，
    # 最好不要在循环语句中使用lambda定义函数。
    original = f
    # for i in range(1,n):
    #     f = lambda x: original(f(x))
    # return f
    
    for i in range(1, n):
        f = lambda x, f=f: original(f(x))
    return f
    def f1(x):
        for i in range(n):
            x = f(x)
        return x
    return f1

add_three = make_repeater(increment, 3)
print(add_three(5))
```