- 高阶函数的环境
	- 对于嵌套定义的函数，内部函数的父Frame是外部函数的Frame(F1)。对于闭包函数，我们将内部函数返回，那么我们就可以在全局Frame中访问该内部函数，同时内部函数的父Frame是F1，因此它可以访问到F1的变量。==`注意这里只是能够读F1的变量，而不能修改，这是因为修改变量时通过赋值语句，而这在python中会以为你新定义了一个父Frame的同名变量。此时我们需要global或nonlocal关键词声明后才可修改(对于全局Frame是global；对于嵌套函数是nonlocal)`==
	- Local Names ---- 不在全局Frame中的变量名
	- 代码示例[L5-1](L5-1.md)


- Lambda 表达式 --- 评估为函数的表达式
	- `square = lambda x: x*x`
	- lambda表达式与def定义函数几乎一致 --- 唯一区别:只有def语句为函数赋予内在名称(就是你画环境图或者打印函数信息的时候的名称)(在实际中没啥用)
		- 这两个函数都有相同的域、表现等
		- 这两个函数都以它们定义的框架为其父框架
		- 两者都将该函数绑定到命名`square`上
	- 一般lambda用于实现简单函数
	- 在==Hw02==的最后一个函数实现时遇到了无限递归的问题具体看[L5-Hw2-1](L5-Hw2-1.md)
		- 函数由 它的栈+它的例程 构成，函数的栈包含 函数内部变量+参数
		- 本质上来讲这是一种无名函数的递归但是没有Base
	

- 函数柯里化 Function Currying
	- 函数柯里化是一种操作函数的方式，将多参数函数转换为一个单参数高阶函数，该函数返回一个接受其余参数的函数

- lambda 和 currying代码示例[L5-2](L5-2.md)